{"title":"C# Puzzlers LiveLessons","uid":9699748,"size":682584190,"categoryP":"other","categoryS":"other","magnet":"?xt=urn:btih:b634034fb25cc9bffe26c642d1acb2dcb4a663d7&amp;dn=C%23+Puzzlers+LiveLessons&amp;tr=udp%3A%2F%2Ftracker.openbittorrent.com%3A80&amp;tr=udp%3A%2F%2Fopen.demonii.com%3A1337&amp;tr=udp%3A%2F%2Ftracker.coppersurfer.tk%3A6969&amp;tr=udp%3A%2F%2Fexodus.desync.com%3A6969","seeders":2,"leechers":1,"uploader":"antignor","files":-1,"time":1393988103,"description":"C# Puzzlers LiveLessons\n-----------------------\n\nOverview\n\nHow well do you know C#? Put your knowledge to the test with Bill WagnerÃ¢â‚¬â„¢s C# Puzzlers video LiveLesson!\n\n \nDescription\n\nThe C# language is more than a decade old, and that maturity means more complexity. This added complexity increases the chances for mistakes and unmaintainable code. Bill regularly presents Ã¢â‚¬Å“C# PuzzlersÃ¢â‚¬ï¿½ at user groups and CodeMash events.  All the Ã¢â‚¬Å“puzzlersÃ¢â‚¬ï¿½ in this LiveLesson have been put to the test with intermediate level developers who tried to break, workaround, and outsmart the code.\n \n\nC# Puzzlers exposes common misconceptions that can occur when developers are unclear about how language features interact or lack understanding about how a single features works. Using the fun Ã¢â‚¬Å“PuzzlerÃ¢â‚¬ï¿½ format, Bill demonstrates these misconceptions via screencasts using small code samples. He gives you an opportunity to figure it out first, and then explores different ways to modify the code until its behavior is correct.\n \n\nThis collection of Puzzlers is divided into six sections. Each section delves into the rules that govern the aspects of the C# language that developers find most confusing:\n \n\nHow the Puzzlers work:\n\n1) Each puzzle shows a reasonably small piece of code, and then asks viewers to guess what the code does.\n\n2) You take the opportunity to try and figure it out.\n\n2) Bill then demonstrates what the code does, and why many developers believe it would behave differently.\n\n3) To close out the lesson he discusses how you could write the code differently to accomplish the same result without the misconceptions.\n \n\nAbout the Instructor\n\nBill Wagner has spent his entire career in the software industry, spanning both technical and business roles. BillÃ¢â‚¬â„¢s technical time is spent between curly braces, primarily with C#. HeÃ¢â‚¬â„¢s the author of the bestselling Ã¢â‚¬Å“Effective C#Ã¢â‚¬ï¿½, now in its second edition, and Ã¢â‚¬Å“More Effective C#Ã¢â‚¬ï¿½. His articles have appeared in MSDN Magazine, the C# Developer Center, Visual C++ DeveloperÃ¢â‚¬â„¢s Journal, Visual Studio Magazine, ASP.NET Pro, .NET DeveloperÃ¢â‚¬â„¢s Journal and more. HeÃ¢â‚¬â„¢s written hundreds of technical articles and actively blogs on technical and business topics.  Bill is also a Microsoft Regional Director.\n\n \nHe spent eight years as a self-employed consultant before co-founding SRT Solutions with Dianne Marsh. Over the past decade, SRT Solutions has grown into a premier software development company, amassing 4 FastTrack awards (2011, 2010, 2008, 2007), the Michigan 50 Companies to Watch award (2011), and making the Inc 500/5000 list (2011 and 2012). Bill was also awarded Automation AlleyÃ¢â‚¬â„¢s Emerging Technology Leader award in 2011.After a successful exit from SRT Solutions, Bill now spends his time helping developers improve their skills.\n\n \nSkill Level\n\nThis topic should be of interest to anyone developing using the C# language. This includes Windows Server, Windows 8, Windows Phone, MonoDroid, and Mono Touch developers at the following skill level:\n\nIntermediate\n\n \nTopics Covered\n\n    Generics\n    Method Resolution\n    Named and Optional Parameters\n    LINQ\n    Value and Reference Semantics\n    Dynamic Programming in C#\n\nWho Should Take This Course\n\nDevelopers: C# programmers\nCourse Requirements: Some experience with C# programming.\n \n\nTable of Contents\n \nThe introductory Puzzler introduces the format using a puzzle, and discusses some of the nuances of object construction.\n \n\nLesson I. Generics\n\nGenerics are still one of the most important aspects of the .NET environment and the C# language. So many of the features we use every day are built upon generics in one way or another. Generics are still a complicated feature. You must create code whose types are not known until runtime. The compiler must generate IL with minimal information about the actual types that will be represented by the type parameters. The JIT must convert that IL into executable code and plug in the real types for the type parameters. Finally, the meta data carried along must include information that enables reflection and other advanced techniques to work correctly.\n \n\nPuzzle 1 - Operations on Generic Type Parameters\nWhat information gets conveyed, and what information cannot get used when a real type is substituted for a type parameter?\n\nPuzzle 2 - Generics and Specializations\nWhat happens when you create overloads for generic methods?\n\nPuzzle 3 - Generics and Variance\nHow do generics and arrays differ with respect to variance?\n\nPuzzle 4 - Generics, Constraints and Overloads\nHow does the compile choose between different candidate generic methods?\n \n\nLesson II. Method Resolution\n \n\nThe rules that govern method resolution in C# are necessarily complex. The features the community has asked for and the team has implemented have only added more complexity to those rules with each new release of the C# language. If you want to be a strong C# developer, you need to have at least a working knowledge of these rules.\n\nPuzzle 5 - Overloading base class methods\nWhat happens when derived classes create overloads of base class methods?\n\nPuzzle 6 - Overloaded methods and null parameters\nHow does the compiler resolve overloaded methods when you use null parameters?\n\nPuzzle 7 - Overloaded methods and null parameters revisited\nWhat if the overloaded parameter types are unrelated?\n\nPuzzle 8 - Overloaded methods and null parameters and Generics\nWhat if one of the methods is generic?\n \n\nLesson III. Named and Optional Parameters\n \n\nNamed and optional parameters sound so simple at first examination. But this feature has significant implications on other features in the language. It also has significant implications on areas as fundamental as how parameters are passed to called methods.\n\nPuzzle 9 - Optional parameters and constructors\nWhen is a default constructor not a default constructor?\n\nPuzzle 10 - Optional Parameters and Overloads\nWhich is the better match?\n\nPuzzle 11- Evaluation of Named Parameters\nWhen do parameters get evaluated? Why does it matter?\n \n\nLesson IV. LINQ\n \nLINQ introduced totally new ways of constructing and organizing programs. There were new rules related to how you wrote algorithms. Those rules still cause developers confusion in some cases.\n\nPuzzle 12 - Bound Variables\nWhen are LINQ queries evaluated?\n\nPuzzle 13 - Method calls in LINQ queries\nHow does LINQ process expressions and method calls?\n \n\nLesson V. Value and Reference Semantics\n\nReference types and value types behave differently in many important ways. They also behave the same in many other ways. It can be difficult to keep those differences in mind as you get too accustomed to the similarities.\n\nPuzzle 14 - Value type Semantics\nWhen does copying values hurt?\n\nPuzzle 15 - Value types and events\nWhat happens when value types receive event notifications?\n \n\nLesson VI. Dynamic Programming in C#\n\nDynamic extensions move many of the common tasks that were performed by the compiler to runtime libraries. The interplay between static and dynamic typing creates new complications in C# programs. This section discusses some of the most common ways where static and dynamic types interact in ways that can be surprising.\n\nPuzzle 16 - Dynamic Types and Extension Methods\nHow do dynamic types interact with extension methods?\n\nPuzzle 17 - Anonymous types and Dynamic Methods\nUnder what conditions can anonymous types be treated dynamically?\n\nPuzzle 18- Creating Dynamic Types in C#\nWhy would you pick different ways to implement dynamic types?\n\n\nCopyright 2012\nEdition: 1st\nISBN-10: 0-13-275698-6\nISBN-13: 978-0-13-275698-3\n &lt;a href=&quot;\nhttps://www.informit.com/store/c-sharp-puzzlers-video-training-9780132756983&quot; rel=&quot;nofollow&quot; target=&quot;_NEW&quot;&gt;\nhttps://www.informit.com/store/c-sharp-puzzlers-video-training-9780132756983&lt;/a&gt;\n\n","torrent":{"xt":"urn:btih:b634034fb25cc9bffe26c642d1acb2dcb4a663d7","amp;dn":"C%23+Puzzlers+LiveLessons","amp;tr":["udp%3A%2F%2Ftracker.openbittorrent.com%3A80","udp%3A%2F%2Fopen.demonii.com%3A1337","udp%3A%2F%2Ftracker.coppersurfer.tk%3A6969","udp%3A%2F%2Fexodus.desync.com%3A6969"],"infoHash":"b634034fb25cc9bffe26c642d1acb2dcb4a663d7","infoHashBuffer":{"type":"Buffer","data":[182,52,3,79,178,92,201,191,254,38,198,66,209,172,178,220,180,166,99,215]},"announce":[],"urlList":[]}}